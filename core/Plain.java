package org.fleen.cloudedPlain.core;

import java.awt.image.BufferedImage;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import javax.sound.sampled.AudioFileFormat;
import javax.sound.sampled.AudioFormat;
import javax.sound.sampled.AudioInputStream;
import javax.sound.sampled.AudioSystem;

import org.fleen.cloudedPlain.core.cloud.Cloud;
import org.fleen.cloudedPlain.core.generator.Generator;

/*
 * A 3D form to be interpreted as a sequence of 2D tile-patterns 
 * to be rendered as video. 
 * 
 * An abstract plain
 * everything but cloud creator
 * 
 * A rectangular array of cells
 * stored as integer values
 * 
 * A bunch of clouds
 */
public class Plain{
  
  /*
   * ################################
   * CONSTRUCTORS
   * ################################
   */
  
  public Plain(){}
  
  public Plain(
    int w,int h,int d,
    Generator cc,
    RendererGraphics rg,RendererSound rs,
    File exportdir,
    PlainProgressListener rendererlistener){
    setDims(w,h,d);
    setGenerator(cc);
    setRendererGraphics(rg);
    setRendererSound(rs);
    setExportDir(exportdir);
    setRendererListener(rendererlistener);}
  
  /*
   * ################################
   * GEOMETRY
   * This plain is a 3d brick
   * the slices are rectangles
   * ################################
   */
  
  //all integers because our pixels are so dense they may as well be floats
  //and int math is fast. and precise. and to scale. 
  public int width,height,duration,centerx,centery;
  
  public void setDims(int w,int h,int d){
    width=w;
    height=h;
    duration =d;
    centerx=w/2;
    centery=h/2;}
  
  /*
   * get all the plain shape cells in this plain
   * for use in getting plain shapes
   */
  public Set<PlainShapeCell> getRawPlainShapeCells(){
    Set<PlainShapeCell> cells=new HashSet<PlainShapeCell>();
    for(int x=0;x<width;x++){
      for(int y=0;y<height;y++){
        cells.add(new PlainShapeCell(x,y,slice[x][y]));}}
    return cells;}
  
  /*
   * ################################
   * CLOUD
   * ################################
   */
  
  /*
   * the plain contains one generator, which may refer to other generators, and so on, treewise
   * There's gotta be a final authority governing cloud generation for this plain. So that's this generator here.
   */
  public Generator generator=null;
  /*
   * All the clouds generated by the generator
   * They are generated, do their thing, then signal to be discarded
   */
  public List<Cloud> clouds=new ArrayList<Cloud>();
  
  public void setGenerator(Generator g){
    this.generator=g;
    g.setPlain(this);}
  
  /*
   * query cloudcreator logic to create 0..n clouds
   * return all created clouds in a list
   */
  protected List<Cloud> generateClouds(){
    List<Cloud> newclouds=generator.generate();
    clouds.addAll(newclouds);
    return newclouds;}
  
  /*
   * discard all clouds that are finished
   * return all discarded clouds in a list
   */
  protected List<Cloud> discardClouds(){
    List<Cloud> d=new ArrayList<Cloud>();
    Iterator<Cloud> i=clouds.iterator();
    Cloud c;
    while(i.hasNext()){
      c=i.next();
      if(c.finished()){
        i.remove();
        d.add(c);}}
    return d;}
  
  /*
   * ################################
   * SLICE
   * a 2D slice of our 3D plain
   * The slice is a 2d array of integers
   * Upon this array the clouds manifest themselves
   * then we render the array as graphics and sound
   * ################################
   */
  
  public int sliceindex;
  public int[][] slice;//the present slice
  
  public int[][] getNextSlice(){
    if(sliceindex==duration)return null;
    //according to each cloud's logic, discard as necessary
    discardClouds();
    //according to cloud creator logic, create clouds
    generateClouds();
    //set all the slice cells' values to 0 in prep for cloud manifestation
    zeroCells();
    //
    manifestCloudsUponSlice();
    sliceindex++;
    return slice;}
  
  private void initSliceIterator(){
    sliceindex=0;
    slice=new int[width][height];
    zeroCells();}
  
  /*
   * set value of all cells to zero in preparation for receiving cloud manifestations 
   */
  public void zeroCells(){
    for(int x=0;x<width;x++)
      for(int y=0;y<height;y++)
        slice[x][y]=0;}
  
  /*
   * manifest all of the clouds, using tslice as param
   * returns true if this is the last slice
   */
  private void manifestCloudsUponSlice(){
    for(Cloud cloud:clouds)
      cloud.manifest();}
  
  /*
   * ################################
   * EXPORT DIR
   * ################################
   */
  
  File exportdir;
  
  public void setExportDir(File d){
    exportdir=d;}
  
  /*
   * ################################
   * RENDER
   * ################################
   */
  
  /*
   * 43200=60*720. 720=1*2*3*4*5*6
   */
  public static final int
    //slices per second. aka video frame rate
    SLICERATE=60,
    //sound sample rate over a single slice. 
    SLICESOUNDSAMPLERATE=720,
    //
    SOUNDSAMPLERATE=SLICERATE*SLICESOUNDSAMPLERATE,
    SOUNDTICKMAXVAL=65535;
  
  public RendererGraphics renderergraphics=null;
  public RendererSound renderersound=null;
  public PlainProgressListener progresslistener=null;
  //the sound data for the plain. A sound of duration equal to plain duration
  public int[] plainsound;
  
  public void setRendererGraphics(RendererGraphics r){
    renderergraphics=r;
    renderergraphics.setPlain(this);}
  
  public void setRendererSound(RendererSound r){
    renderersound=r;
    renderersound.setPlain(this);}
  
  public void setRendererListener(PlainProgressListener l){
    progresslistener=l;}
  
  public void render(){
    System.out.println("render start");
    BufferedImage sliceimage;
    plainsound=new int[duration*SLICESOUNDSAMPLERATE];
    //the sound spanning a single slice. Concactenate them all to get the plain sound 
    int[] slicesound=null;
    //init the slice iterator and get the first slice
    initSliceIterator();
    slice=getNextSlice();
    //MAIN SLICE GETTING AND RENDERING LOOP
    while(slice!=null){
      //render the image and sound
      sliceimage=renderergraphics.render(slice);
      slicesound=renderersound.render(slice);
      //stick the image in the image export dir, stick the slice sound in the plain sound array 
      exportSliceImage(sliceimage);
      System.arraycopy(slicesound,0,plainsound,(sliceindex-1)*SLICESOUNDSAMPLERATE,slicesound.length);
      //notify the listener
      progresslistener.notify(this,sliceimage,slicesound);
      //get the next slice
      slice=getNextSlice();}
    //create sound file from sound array and write it to a wav or whatever
    exportSound();
    System.out.println("render end");}
  
  /*
   * ################################
   * EXPORT
   * ################################
   */
  
  RasterExporter rasterexporter=new RasterExporter();
  
  private void exportSliceImage(BufferedImage sliceimage){
    if(!exportdir.isDirectory())exportdir.mkdir();
    rasterexporter.export(sliceimage,sliceindex,exportdir);
    
    
  }
  
  private void exportSound(){
    //convert int array to byte array
    //2 bytes per sound tick. so max sound tick value is 65536
    final byte[] soundbytes = new byte[plainsound.length*2];
    for(int i=0;i<plainsound.length;i++){
      soundbytes[i*2]=(byte)plainsound[i];
      soundbytes[i*2+1]=(byte)(plainsound[i]>>>8);}
    //output the file
    File out = new File(exportdir.getAbsolutePath()+"/plain.wav");
    boolean bigEndian = false;
    boolean signed = true;
    int bits = 16;
    int channels = 1;
    AudioFormat format;
    format = new AudioFormat((float)SOUNDSAMPLERATE, bits, channels, signed, bigEndian);
    ByteArrayInputStream bais = new ByteArrayInputStream(soundbytes);
    AudioInputStream audioInputStream;
    audioInputStream = new AudioInputStream(bais,format,plainsound.length);
    try{
      AudioSystem.write(audioInputStream, AudioFileFormat.Type.WAVE, out);
      audioInputStream.close();
    }catch(Exception x){
      x.printStackTrace();}}
  
  

}
