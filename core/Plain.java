package org.fleen.cloudedPlain.core;

import java.awt.image.BufferedImage;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import javax.sound.sampled.AudioFileFormat;
import javax.sound.sampled.AudioFormat;
import javax.sound.sampled.AudioInputStream;
import javax.sound.sampled.AudioSystem;

import org.fleen.cloudedPlain.core.renderAudio.RendererSound;
import org.fleen.cloudedPlain.core.renderVideo.RasterExporter;
import org.fleen.cloudedPlain.core.renderVideo.RendererGraphics;
import org.fleen.cloudedPlain.core.stripeGenerators.StripeGenerator;

/*
 * A 3D form to be interpreted as a sequence of 2D tile-patterns 
 * to be rendered as video. 
 * 
 * An abstract plain
 * everything but Stripe creator
 * 
 * A rectangular array of cells
 * stored as integer values
 * 
 * A bunch of Stripes
 */
public class Plain implements CPRectangle{
  
  /*
   * ################################
   * CONSTRUCTORS
   * ################################
   */
  
  public Plain(){}
  
  public Plain(
    int w,int h,int d,
    StripeGenerator cc,
    RendererGraphics rg,RendererSound rs,
    File exportdir,
    RenderingProgressListener rendererlistener){
    setDims(w,h,d);
    setGenerator(cc);
    setRendererGraphics(rg);
    setRendererSound(rs);
    setExportDir(exportdir);
    setRendererListener(rendererlistener);}
  
  /*
   * ################################
   * IMPLEMENTATION OF CPRectangle
   * ################################
   */
  
  public int getCoorX(){
    return 0;}
  
  public int getCoorY(){
    return 0;}

  public int getWidth(){
    return width;}

  public int getHeight(){
    return height;}
  
  /*
   * ################################
   * GEOMETRY
   * This plain is a 3d brick
   * the slices are rectangles
   * ################################
   */
  
  //all integers because our pixels are so dense they may as well be floats
  //and int math is fast. and precise. and to scale. 
  public int width,height,duration,centerx,centery;
  
  public void setDims(int w,int h,int d){
    width=w;
    height=h;
    duration =d;
    centerx=w/2;
    centery=h/2;}
  
  /*
   * ################################
   * Stripe Generators
   * ################################
   */
  
  /*
   * the plain contains one generator, which may refer to other generators, and so on, treewise
   * There's gotta be a final authority governing Stripe generation for this plain. So that's this generator here.
   */
  public StripeGenerator generator=null;
  /*
   * All the Stripes generated by the generator
   * They are generated, do their thing, then signal to be discarded
   */
  public List<CPStripe> stripes=new ArrayList<CPStripe>();
  
  public void setGenerator(StripeGenerator g){
    this.generator=g;
    g.setPlain(this);}
  
  /*
   * query Stripecreator logic to create 0..n Stripes
   * return all created Stripes in a list
   */
  protected List<Stripe_Sweeper> generateStripes(){
    List<Stripe_Sweeper> newstripes=generator.generate();
    stripes.addAll(newstripes);
    return newstripes;}
  
  /*
   * get the stripes that are ready to be destroyed
   * remove them from the stripes list
   */
  protected List<CPStripe> getStripesToDestroy(){
    List<CPStripe> d=new ArrayList<CPStripe>();
    Iterator<CPStripe> i=stripes.iterator();
    CPStripe c;
    while(i.hasNext()){
      c=i.next();
      if(c.destroyMe()){
        i.remove();
        d.add(c);}}
    return d;}
  
  /*
   * ################################
   * FRAME
   * a 1/60th of a second piece of our process
   * a frame image
   * The slice is a 2d array of integers
   * Upon this array the Stripes manifest themselves
   * then we render the array as graphics and sound
   * ################################
   */
  
  public int frameindex;
  public int[][] frame;//the present slice
  
  public int[][] getNextFrame(){
    if(frameindex==duration)return null;
    //according to each Stripe's logic, discard as necessary
    getStripesToDestroy();
    //according to Stripe creator logic, create Stripes
    generateStripes();
    //set all the slice cells' values to 0 in prep for Stripe manifestation
    zeroCells();
    //
    manifestStripesUponSlice();//map Stripes to plain cells
//    shapes=null;//invalidate shapes so they get remapped
    frameindex++;
    return frame;}
  
  private void initFrameIterator(){
    frameindex=0;
    frame=new int[width][height];
    zeroCells();}
  
  /*
   * set value of all cells to zero in preparation for receiving Stripe manifestations 
   */
  public void zeroCells(){
    for(int x=0;x<width;x++)
      for(int y=0;y<height;y++)
        frame[x][y]=0;}
  
  /*
   * manifest all of the Stripes, using tslice as param
   * returns true if this is the last slice
   */
  private void manifestStripesUponSlice(){
    for(Stripe_Sweeper Stripe:stripes)
      Stripe.manifest();}
  
  /*
   * ################################
   * EXPORT DIR
   * ################################
   */
  
  File exportdir;
  
  public void setExportDir(File d){
    exportdir=d;}
  
  /*
   * ################################
   * RENDER
   * ################################
   */
  
  /*
   * 43200=60*720. 720=1*2*3*4*5*6
   */
  public static final int
    //slices per second. aka video frame rate
    SLICERATE=60,
    //sound sample rate over a single slice. 
    FRAMESOUNDSAMPLERATE=720,
    //
    SOUNDSAMPLERATE=SLICERATE*FRAMESOUNDSAMPLERATE,
    SOUNDTICKMAXVAL=65535;
  
  public RendererGraphics renderergraphics=null;
  public RendererSound renderersound=null;
  public RenderingProgressListener progresslistener=null;
  //the sound data for the plain. A sound of duration equal to plain duration
  public int[] plainsound;
  
  public void setRendererGraphics(RendererGraphics r){
    renderergraphics=r;
    renderergraphics.setPlain(this);}
  
  public void setRendererSound(RendererSound r){
    renderersound=r;
    renderersound.setPlain(this);}
  
  public void setRendererListener(RenderingProgressListener l){
    progresslistener=l;}
  
  public void render(){
    System.out.println("render start");
    BufferedImage frameimage;
    plainsound=new int[duration*FRAMESOUNDSAMPLERATE];
    //the sound spanning a single slice. Concactenate them all to get the plain sound 
    int[] framesound=null;
    //init the frame iterator and get the first frame
    initFrameIterator();
    frame=getNextFrame();
    //MAIN FRAME GETTING AND RENDERING LOOP
    while(frame!=null){
      //render the image and sound
      frameimage=renderergraphics.render(frame);
      framesound=renderersound.render(frame);
      rasterexporter.export(frameimage,frameindex,exportdir);
      System.arraycopy(framesound,0,plainsound,(frameindex-1)*FRAMESOUNDSAMPLERATE,framesound.length);
      progresslistener.notify(this,frameimage,framesound);
      frame=getNextFrame();}
    System.out.println("export sound");
    exportSound();
    System.out.println("render end");}
  
  /*
   * ################################
   * EXPORT
   * ################################
   */
  
  RasterExporter rasterexporter=new RasterExporter();
  
  private void exportSound(){
    //convert int array to byte array
    //2 bytes per sound tick. so max sound tick value is 65536
    final byte[] soundbytes = new byte[plainsound.length*2];
    for(int i=0;i<plainsound.length;i++){
      soundbytes[i*2]=(byte)plainsound[i];
      soundbytes[i*2+1]=(byte)(plainsound[i]>>>8);}
    //output the file
    File out = new File(exportdir.getAbsolutePath()+"/plain.wav");
    boolean bigEndian = false;
    boolean signed = true;
    int bits = 16;
    int channels = 1;
    AudioFormat format;
    format = new AudioFormat((float)SOUNDSAMPLERATE, bits, channels, signed, bigEndian);
    ByteArrayInputStream bais = new ByteArrayInputStream(soundbytes);
    AudioInputStream audioInputStream;
    audioInputStream = new AudioInputStream(bais,format,plainsound.length);
    try{
      AudioSystem.write(audioInputStream, AudioFileFormat.Type.WAVE, out);
      audioInputStream.close();
    }catch(Exception x){
      x.printStackTrace();}}
  
  /*
   * ################################
   * GET CHUNKS
   * ################################
   * Given this system of plain and stripes
   * get all of the chunks formed via their intersections
   * 
   * A NEW IDEA
   * first intersect all of the vertical stripes (with each other and a plain-shaped chunk)
   * then intersect all the horizontal (with each other and a plain-shaped chunk) 
   * this gives us 2 skeins of nonoverlapping chunks
   * now intersect the two in some kind of orderly way
   * that should do it.
   * 
   * 
   */
  
  public List<Chunk> getChunks(){
    //sort the stripes into vertical and horizontal groups
    List<CPStripe> 
      vstripes=new ArrayList<CPStripe>(),
      hstripes=new ArrayList<CPStripe>();
    for(CPStripe stripe:stripes){
      if(stripe.isHorizontal())
        hstripes.add(stripe);
      else
        vstripes.add(stripe);}
    //intersect each group, resolve overlaps, get chunks
    List<Chunk> 
      vchunks=getVerticalChunks(hstripes),
      hchunks=getHorizontalChunks(vstripes),
      //intersect our 2 chunk groups
      finalchunks=getChunks(vchunks,hchunks);
    return finalchunks;}
  
  /*
   * convert the list of vertical stripes and the plain-rectangle into a sequence of chunk terminuses (VChunkTerminus class object)
   * each VChunkTerminus 
   *   has an X coordinate, describing its location on the horizontal span of the plain
   *   holds a list of all the stripes that stop or start there 
   * 
   *  
   */
  List<Chunk> getVerticalChunks(List<CPStripe> vstripes){
    List<VChunkTerminus> terminusses=getOrderedTermunsesses(vstripes);
    List<Chunk> chunks=convertTerminussesToVerticalChunks(terminusses);
    return chunks;}
  
  /*
   * address the sequence of terminusses
   * at each terminus except for the last, create a chunk
   * 
   */
  private List<Chunk> convertTerminussesToVerticalChunks(List<VChunkTerminus> terminusses){
    
  }
  
  /*
   * convert the list of vertical stripes to an ordered list of vertical chunk terminusses
   * for each stripe
   *   get a terminus
   *   first check the termsbyx map.
   *   if it isn't there then create one and stick it in the map
   * now er have our terminusesses, unordered
   * sort them by xcoors
   * that's it
   */
  List<VChunkTerminus> getOrderedTermunsesses(List<CPStripe> vstripes){
    Map<Integer,VChunkTerminus> termsbyx=new HashMap<Integer,VChunkTerminus>();
    VChunkTerminus t;
    int xmin,xmax;
    for(CPStripe s:vstripes){
      //do terminus for east edge of stripe
      xmin=s.getXMin();
      t=termsbyx.get(xmin);
      if(t==null){
        t=new VChunkTerminus(this,xmin);
        termsbyx.put(xmin,t);}
      t.stripeeastedge.add(s);
      //do terminus for west edge of stripe
      xmax=s.getXMax();
      t=termsbyx.get(xmax);
      if(t==null){
        t=new VChunkTerminus(this,xmax);
        termsbyx.put(xmax,t);}
      t.stripewestedge.add(s);}
    //sort the terminusses
    List<VChunkTerminus> ordered=new ArrayList<VChunkTerminus>(termsbyx.values());
    Collections.sort(ordered);
    //
    return ordered;}
  
  
  class VChunkTerminus implements Comparable<VChunkTerminus>{
    
    Plain plain;
    int xcoor;
    
    List<CPStripe>
      //all stripes in the list have their west edge here
      stripewestedge=new ArrayList<CPStripe>(),
      //all stripes in the list have their east edge here
      stripeeastedge=new ArrayList<CPStripe>();
    
    VChunkTerminus(Plain plain,int xcoor){
      this.plain=plain;
      this.xcoor=xcoor;}
    
    boolean isPlainWestEdge(){
      return xcoor==0;}
    
    boolean isPlainEastEdge(){
      return xcoor==plain.getWidth()-1;}

    public int compareTo(VChunkTerminus a){
      if(xcoor==a.xcoor){
        throw new IllegalArgumentException("2 VChunkTerminus can't have the same xcoor : "+xcoor);
      }else if(xcoor>a.xcoor){
        return 1;
      }else{
        return 0;}}
    
    
    
    
  }


  
  /*
   * A little geometry
   */
  
  public int getXMin(){
    return 0;}

  public int getXMax(){
    return getWidth()-1;}

  public int getYMin(){
    return 0;}

  public int getYMax(){
    return getHeight()-1;}

}
